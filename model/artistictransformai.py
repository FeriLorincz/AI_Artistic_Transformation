# -*- coding: utf-8 -*-
"""ArtisticTransformAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1es_9yBqyZcI3ppz3SckQvSiK0uXp9AMP

Instalăm tensorflow_addons
"""

!pip install tensorflow_addons

import tensorflow as tf
import tensorflow_addons as tfa
import numpy as np
import matplotlib.pyplot as plt
import os
from glob import glob
import time
from zipfile import ZipFile

"""# Importăm bibliotecile necesare"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import os
from glob import glob
from zipfile import ZipFile

"""Verificăm conținutul din sample_data"""

!ls /content/sample_data

"""Extragem arhiva"""

!unzip -q "/content/sample_data/photosanddrawings.zip" -d "/content/dataset"

"""# Verificăm device-ul disponibil

Verificăm dacă extragerea a funcționat
"""

!ls /content/dataset

"""Acum că avem datele corect organizate, să continuăm cu încărcarea și preprocesarea imaginilor. Vom folosi un cod simplificat, fără tensorflow_addons pentru moment.


Adaugă o funcție natural_sort_key care sortează fișierele după numărul din nume
Afișează căile către fișiere pentru a verifica ordinea
Afișează mai multe perechi de imagini pentru verificare
Include verificări pentru a ne asigura că numărul de fotografii și desene este egal

Rulează acest cod și verifică dacă:

Ordinea fișierelor afișată în console este corectă (numerele ar trebui să fie în ordine)
Perechile de imagini afișate corespund (aceleași numere)
Sunt afișate primele 3 perechi de imagini
"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import os
from glob import glob
import re

def natural_sort_key(s):
    # Extrage numărul din numele fișierului
    numbers = re.findall(r'\d+', s)
    if numbers:
        return int(numbers[0])
    return 0

# Setăm parametrii globali
BUFFER_SIZE = 256
BATCH_SIZE = 1
IMG_WIDTH = 256
IMG_HEIGHT = 256

def load_and_preprocess_image(image_path):
    image = tf.io.read_file(image_path)
    image = tf.image.decode_jpeg(image, channels=3)
    image = tf.image.resize(image, [IMG_HEIGHT, IMG_WIDTH])
    image = (tf.cast(image, tf.float32) / 127.5) - 1
    return image

# Obținem căile către imagini și le sortăm după număr
photo_paths = sorted(glob('/content/dataset/photos/*'), key=natural_sort_key)
drawing_paths = sorted(glob('/content/dataset/drawings/*'), key=natural_sort_key)

print("Căi către fotografii:")
for path in photo_paths:
    print(path)
print("\nCăi către desene:")
for path in drawing_paths:
    print(path)

print(f"\nNumăr de fotografii: {len(photo_paths)}")
print(f"Număr de desene: {len(drawing_paths)}")

# Verificăm că avem același număr de imagini în ambele seturi
assert len(photo_paths) == len(drawing_paths), "Numărul de fotografii și desene nu este egal!"

# Creăm dataset-urile
photo_dataset = tf.data.Dataset.from_tensor_slices(photo_paths)
drawing_dataset = tf.data.Dataset.from_tensor_slices(drawing_paths)

photo_dataset = photo_dataset.map(load_and_preprocess_image)
drawing_dataset = drawing_dataset.map(load_and_preprocess_image)

photo_dataset = photo_dataset.batch(BATCH_SIZE)
drawing_dataset = drawing_dataset.batch(BATCH_SIZE)

# Funcție pentru vizualizarea mai multor perechi
def plot_pairs(photos, drawings, num_pairs=3):
    plt.figure(figsize=(20, 4*num_pairs))
    for i in range(min(num_pairs, len(photos))):
        # Fotografie
        plt.subplot(num_pairs, 2, 2*i + 1)
        plt.title(f'Fotografie {i+1}')
        plt.imshow(photos[i][0] * 0.5 + 0.5)
        plt.axis('off')

        # Desen
        plt.subplot(num_pairs, 2, 2*i + 2)
        plt.title(f'Desen {i+1}')
        plt.imshow(drawings[i][0] * 0.5 + 0.5)
        plt.axis('off')
    plt.tight_layout()
    plt.show()

# Convertim dataset-urile în liste pentru vizualizare
photos = list(photo_dataset.take(3))
drawings = list(drawing_dataset.take(3))

# Afișăm primele 3 perechi
plot_pairs(photos, drawings, 3)

"""Acum că avem datele organizate corect, putem trece la construirea arhitecturii modelului CycleGAN. Vom implementa generatoarele și discriminatoarele necesare pentru transformarea stilului.
Acest cod definește arhitectura modelului CycleGAN cu:

Un generator pentru transformarea fotografiilor în desene (generator_g)
Un generator pentru transformarea desenelor înapoi în fotografii (generator_f)
Doi discriminatori pentru a evalua autenticitatea imaginilor generate

Caracteristici cheie:

Folosește arhitectură U-Net pentru generatoare cu skip connections
Include batch normalization și dropout pentru stabilitate
Folosește funcții de activare LeakyReLU și ReLU
"""

import tensorflow as tf

def downsample(filters, size, apply_batchnorm=True):
    initializer = tf.random_normal_initializer(0., 0.02)

    result = tf.keras.Sequential()
    result.add(tf.keras.layers.Conv2D(filters, size, strides=2, padding='same',
                                     kernel_initializer=initializer, use_bias=False))

    if apply_batchnorm:
        result.add(tf.keras.layers.BatchNormalization())

    result.add(tf.keras.layers.LeakyReLU())
    return result

def upsample(filters, size, apply_dropout=False):
    initializer = tf.random_normal_initializer(0., 0.02)

    result = tf.keras.Sequential()
    result.add(tf.keras.layers.Conv2DTranspose(filters, size, strides=2,
                                              padding='same',
                                              kernel_initializer=initializer,
                                              use_bias=False))

    result.add(tf.keras.layers.BatchNormalization())

    if apply_dropout:
        result.add(tf.keras.layers.Dropout(0.5))

    result.add(tf.keras.layers.ReLU())
    return result

def Generator():
    inputs = tf.keras.layers.Input(shape=[256, 256, 3])

    # Encoder
    down_stack = [
        downsample(64, 4, apply_batchnorm=False),  # (128, 128, 64)
        downsample(128, 4),  # (64, 64, 128)
        downsample(256, 4),  # (32, 32, 256)
        downsample(512, 4),  # (16, 16, 512)
        downsample(512, 4),  # (8, 8, 512)
        downsample(512, 4),  # (4, 4, 512)
        downsample(512, 4),  # (2, 2, 512)
        downsample(512, 4),  # (1, 1, 512)
    ]

    # Decoder
    up_stack = [
        upsample(512, 4, apply_dropout=True),  # (2, 2, 1024)
        upsample(512, 4, apply_dropout=True),  # (4, 4, 1024)
        upsample(512, 4, apply_dropout=True),  # (8, 8, 1024)
        upsample(512, 4),  # (16, 16, 1024)
        upsample(256, 4),  # (32, 32, 512)
        upsample(128, 4),  # (64, 64, 256)
        upsample(64, 4),  # (128, 128, 128)
    ]

    initializer = tf.random_normal_initializer(0., 0.02)
    last = tf.keras.layers.Conv2DTranspose(3, 4,
                                         strides=2,
                                         padding='same',
                                         kernel_initializer=initializer,
                                         activation='tanh')  # (256, 256, 3)

    x = inputs
    # Salvăm conexiunile pentru skip connections
    skips = []
    for down in down_stack:
        x = down(x)
        skips.append(x)

    skips = reversed(skips[:-1])

    # Adăugăm skip connections
    for up, skip in zip(up_stack, skips):
        x = up(x)
        x = tf.keras.layers.Concatenate()([x, skip])

    x = last(x)

    return tf.keras.Model(inputs=inputs, outputs=x)

def Discriminator():
    initializer = tf.random_normal_initializer(0., 0.02)

    inp = tf.keras.layers.Input(shape=[256, 256, 3], name='input_image')

    x = inp

    down1 = downsample(64, 4, False)(x)  # (128, 128, 64)
    down2 = downsample(128, 4)(down1)  # (64, 64, 128)
    down3 = downsample(256, 4)(down2)  # (32, 32, 256)

    zero_pad1 = tf.keras.layers.ZeroPadding2D()(down3)  # (34, 34, 256)
    conv = tf.keras.layers.Conv2D(512, 4, strides=1,
                                kernel_initializer=initializer,
                                use_bias=False)(zero_pad1)  # (31, 31, 512)

    batchnorm1 = tf.keras.layers.BatchNormalization()(conv)
    leaky_relu = tf.keras.layers.LeakyReLU()(batchnorm1)

    zero_pad2 = tf.keras.layers.ZeroPadding2D()(leaky_relu)  # (33, 33, 512)
    last = tf.keras.layers.Conv2D(1, 4, strides=1,
                                kernel_initializer=initializer)(zero_pad2)  # (30, 30, 1)

    return tf.keras.Model(inputs=inp, outputs=last)

# Instantiem modelele
generator_g = Generator()  # Generator pentru Foto -> Desen
generator_f = Generator()  # Generator pentru Desen -> Foto

discriminator_x = Discriminator()  # Discriminator pentru fotografii
discriminator_y = Discriminator()  # Discriminator pentru desene

# Afișăm un sumar al arhitecturii
print("Generator Summary:")
generator_g.summary()

print("\nDiscriminator Summary:")
discriminator_x.summary()

"""Loss Function and Training Loop

Hai să implementăm funcțiile de pierdere și bucla de antrenare.

Acest cod implementează:

Funcțiile de pierdere necesare (generator, discriminator, cycle, identity)
Optimizatorii pentru toate modelele
Un sistem de checkpoint pentru salvarea progresului
O buclă de antrenare completă care:

Antrenează modelul pentru 40 de epoci
Salvează checkpoint-uri la fiecare 5 epoci
Generează exemple la fiecare 5 epoci
Afișează valorile loss-urilor pentru monitorizare
"""

import time

# Definim hiperparametrii
LAMBDA = 10
EPOCHS = 40
checkpoint_path = "./checkpoints/train"

# Funcții de pierdere
loss_obj = tf.keras.losses.BinaryCrossentropy(from_logits=True)

def discriminator_loss(real, generated):
    real_loss = loss_obj(tf.ones_like(real), real)
    generated_loss = loss_obj(tf.zeros_like(generated), generated)
    total_disc_loss = real_loss + generated_loss
    return total_disc_loss * 0.5

def generator_loss(generated):
    return loss_obj(tf.ones_like(generated), generated)

def calc_cycle_loss(real_image, cycled_image):
    loss1 = tf.reduce_mean(tf.abs(real_image - cycled_image))
    return LAMBDA * loss1

def identity_loss(real_image, same_image):
    loss = tf.reduce_mean(tf.abs(real_image - same_image))
    return LAMBDA * 0.5 * loss

# Optimizatori
generator_g_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1=0.5)
generator_f_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1=0.5)
discriminator_x_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1=0.5)
discriminator_y_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1=0.5)

# Checkpoint pentru salvarea modelului
checkpoint = tf.train.Checkpoint(
    generator_g=generator_g,
    generator_f=generator_f,
    discriminator_x=discriminator_x,
    discriminator_y=discriminator_y,
    generator_g_optimizer=generator_g_optimizer,
    generator_f_optimizer=generator_f_optimizer,
    discriminator_x_optimizer=discriminator_x_optimizer,
    discriminator_y_optimizer=discriminator_y_optimizer
)

@tf.function
def train_step(real_x, real_y):
    with tf.GradientTape(persistent=True) as tape:
        # Generator G translates X -> Y
        # Generator F translates Y -> X

        fake_y = generator_g(real_x, training=True)
        cycled_x = generator_f(fake_y, training=True)

        fake_x = generator_f(real_y, training=True)
        cycled_y = generator_g(fake_x, training=True)

        # same_x și same_y sunt folosite pentru loss-ul de identitate
        same_x = generator_f(real_x, training=True)
        same_y = generator_g(real_y, training=True)

        # Discriminator outputs
        disc_real_x = discriminator_x(real_x, training=True)
        disc_real_y = discriminator_y(real_y, training=True)
        disc_fake_x = discriminator_x(fake_x, training=True)
        disc_fake_y = discriminator_y(fake_y, training=True)

        # Generator loss
        gen_g_loss = generator_loss(disc_fake_y)
        gen_f_loss = generator_loss(disc_fake_x)

        # Cycle loss
        total_cycle_loss = calc_cycle_loss(real_x, cycled_x) + calc_cycle_loss(real_y, cycled_y)

        # Identity loss
        total_gen_g_loss = gen_g_loss + total_cycle_loss + identity_loss(real_y, same_y)
        total_gen_f_loss = gen_f_loss + total_cycle_loss + identity_loss(real_x, same_x)

        # Discriminator loss
        disc_x_loss = discriminator_loss(disc_real_x, disc_fake_x)
        disc_y_loss = discriminator_loss(disc_real_y, disc_fake_y)

    # Calculăm gradienții
    generator_g_gradients = tape.gradient(total_gen_g_loss, generator_g.trainable_variables)
    generator_f_gradients = tape.gradient(total_gen_f_loss, generator_f.trainable_variables)
    discriminator_x_gradients = tape.gradient(disc_x_loss, discriminator_x.trainable_variables)
    discriminator_y_gradients = tape.gradient(disc_y_loss, discriminator_y.trainable_variables)

    # Aplicăm gradienții
    generator_g_optimizer.apply_gradients(zip(generator_g_gradients, generator_g.trainable_variables))
    generator_f_optimizer.apply_gradients(zip(generator_f_gradients, generator_f.trainable_variables))
    discriminator_x_optimizer.apply_gradients(zip(discriminator_x_gradients, discriminator_x.trainable_variables))
    discriminator_y_optimizer.apply_gradients(zip(discriminator_y_gradients, discriminator_y.trainable_variables))

    return {
        'gen_g_loss': total_gen_g_loss,
        'gen_f_loss': total_gen_f_loss,
        'disc_x_loss': disc_x_loss,
        'disc_y_loss': disc_y_loss
    }

# Funcție pentru generarea și salvarea imaginilor în timpul antrenării
def generate_images(model, test_input):
    prediction = model(test_input)

    plt.figure(figsize=(12, 6))

    display_list = [test_input[0], prediction[0]]
    title = ['Input Image', 'Generated Image']

    for i in range(2):
        plt.subplot(1, 2, i+1)
        plt.title(title[i])
        plt.imshow(display_list[i] * 0.5 + 0.5)
        plt.axis('off')
    plt.show()

# Bucla de antrenare
print("Începem antrenarea...")
for epoch in range(EPOCHS):
    start = time.time()

    for image_x, image_y in tf.data.Dataset.zip((photo_dataset, drawing_dataset)):
        losses = train_step(image_x, image_y)

    if (epoch + 1) % 5 == 0:
        checkpoint.save(file_prefix=checkpoint_path)

    print(f'Epoch {epoch + 1}/{EPOCHS}')
    print(f'gen_g_loss={losses["gen_g_loss"]:.4f}, gen_f_loss={losses["gen_f_loss"]:.4f}')
    print(f'disc_x_loss={losses["disc_x_loss"]:.4f}, disc_y_loss={losses["disc_y_loss"]:.4f}')
    print(f'Time taken: {time.time()-start:.2f} sec\n')

    if (epoch + 1) % 5 == 0:
        # Generăm și afișăm câteva exemple
        for inp in photo_dataset.take(1):
            generate_images(generator_g, inp)

print("Antrenare finalizată!")

"""Salvăm modelul generator_g pentru conversia la TFLite"""

# Salvăm modelul în format keras
generator_g.save('generator_g.keras')

# Exportăm pentru TensorFlow Lite
export_dir = 'generator_g_export'
tf.saved_model.save(generator_g, export_dir)

# Convertim la TFLite
converter = tf.lite.TFLiteConverter.from_saved_model(export_dir)
converter.optimizations = [tf.lite.Optimize.DEFAULT]
converter.target_spec.supported_types = [tf.float32]

# Pentru debugging, adăugăm mai multe informații
print("Începem conversia...")
try:
    tflite_model = converter.convert()
    print("Conversia a reușit!")

    # Salvăm modelul TFLite
    with open('model.tflite', 'wb') as f:
        f.write(tflite_model)
    print("Model salvat ca 'model.tflite'")

    # Afișăm dimensiunea modelului
    print(f"Dimensiunea modelului: {len(tflite_model) / 1024 / 1024:.2f} MB")

except Exception as e:
    print("Eroare la conversie:", str(e))

"""facem din nou un test

"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt

# Definim modelul generator
def make_generator_model():
    model = tf.keras.Sequential([
        tf.keras.layers.InputLayer(input_shape=(256, 256, 3)),

        # Encoder - redus la jumătate
        tf.keras.layers.Conv2D(32, 3, strides=2, padding='same'),
        tf.keras.layers.LeakyReLU(),

        tf.keras.layers.Conv2D(64, 3, strides=2, padding='same'),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.LeakyReLU(),

        # Transformer - simplificat
        tf.keras.layers.Conv2D(128, 3, padding='same'),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.LeakyReLU(),

        # Decoder - redus la jumătate
        tf.keras.layers.Conv2DTranspose(64, 3, strides=2, padding='same'),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.ReLU(),

        tf.keras.layers.Conv2DTranspose(32, 3, strides=2, padding='same'),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.ReLU(),

        tf.keras.layers.Conv2D(3, 3, padding='same', activation='tanh')
    ])
    return model

# Convertim în TFLite cu optimizări
converter = tf.lite.TFLiteConverter.from_keras_model(make_generator_model())
converter.optimizations = [tf.lite.Optimize.DEFAULT]
converter.target_spec.supported_types = [tf.float32]
converter.target_spec.supported_ops = [
    tf.lite.OpsSet.TFLITE_BUILTINS,
    tf.lite.OpsSet.SELECT_TF_OPS
]

tflite_model = converter.convert()

# Salvăm modelul
with open('model_lite.tflite', 'wb') as f:
    f.write(tflite_model)

print("Model convertit și salvat cu succes!")